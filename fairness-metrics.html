<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Fairness Metrics Explorer - AI for Healthcare</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #f5f7fa;
    color: #2c3e50;
    margin: 0;
    padding: 20px;
    line-height: 1.6;
  }

  .container {
    max-width: 900px;
    margin: 0 auto;
  }

  .back-button {
    display: inline-block;
    color: white;
    background: #3498db;
    text-decoration: none;
    margin-bottom: 15px;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 0.85em;
    font-weight: 500;
    transition: background 0.2s;
  }

  .back-button:hover {
    background: #2980b9;
  }

  h1 {
    font-size: 1.5em;
    margin-bottom: 10px;
    color: #1a1a1a;
  }

  .subtitle {
    color: #666;
    margin-bottom: 25px;
    font-size: 0.95em;
  }

  /* Card component */
  .card {
    background: white;
    border-radius: 10px;
    padding: 18px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  }

  .card-title {
    font-size: 1.1em;
    font-weight: 600;
    margin: 0 0 10px 0;
    color: #1a1a1a;
  }

  .card-subtitle {
    color: #666;
    font-size: 0.9em;
    margin-bottom: 20px;
  }

  /* Collapsible intro */
  .collapsible-toggle {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 12px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    font-size: 0.95em;
    font-weight: 600;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s;
  }

  .collapsible-toggle:hover {
    border-color: #3498db;
    color: #3498db;
  }

  .arrow {
    font-size: 0.8em;
    transition: transform 0.2s;
  }

  .arrow.open {
    transform: rotate(90deg);
  }

  .collapsible-content {
    display: none;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 20px;
    margin-top: 10px;
    margin-bottom: 20px;
  }

  .collapsible-content.visible {
    display: block;
  }

  .collapsible-content h3 {
    font-size: 1em;
    margin: 15px 0 10px 0;
    color: #2c3e50;
  }

  .collapsible-content h3:first-child {
    margin-top: 0;
  }

  .collapsible-content p, .collapsible-content ul {
    font-size: 0.9em;
    color: #495057;
  }

  .collapsible-content dl {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 6px;
    font-size: 0.9em;
  }

  .collapsible-content dt {
    font-weight: 600;
    margin-top: 10px;
    color: #1a1a1a;
  }

  .collapsible-content dt:first-child {
    margin-top: 0;
  }

  .collapsible-content dd {
    margin: 5px 0 0 0;
    color: #555;
  }

  /* Confusion matrix input grid */
  .groups-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    margin-bottom: 20px;
  }

  @media (max-width: 700px) {
    .groups-grid {
      grid-template-columns: 1fr;
      gap: 25px;
    }
  }

  .group-section {
    text-align: center;
  }

  .group-label {
    font-weight: 600;
    font-size: 1em;
    margin-bottom: 6px;
  }

  .group-a { color: #2980b9; }
  .group-b { color: #e67e22; }

  .matrix-input-grid {
    display: grid;
    grid-template-columns: 90px 1fr 1fr;
    grid-template-rows: 35px 1fr 1fr;
    gap: 6px;
    max-width: 280px;
    margin: 0 auto;
    font-size: 0.85em;
  }

  .matrix-corner {
    background: transparent;
  }

  .matrix-col-header,
  .matrix-row-header {
    background: #e8e8e8;
    padding: 6px 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 0.7em;
    color: #666;
    border-radius: 4px;
    text-align: center;
  }

  .matrix-row-header {
    /* Changed to horizontal orientation */
  }

  .matrix-input-cell {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 5px;
    border-radius: 6px;
    border: 2px solid #e0e0e0;
    transition: border-color 0.2s;
  }

  .matrix-input-cell:focus-within {
    border-color: #3498db;
  }

  .tp-cell, .tn-cell { background: #e8f5e9; }
  .fp-cell, .fn-cell { background: #ffebee; }

  .cell-label {
    font-size: 0.75em;
    font-weight: 600;
    color: #666;
    margin-bottom: 4px;
    text-transform: uppercase;
  }

  .matrix-input {
    width: 50px;
    padding: 4px;
    font-size: 1.1em;
    font-weight: 600;
    text-align: center;
    border: 2px solid #3498db;
    border-radius: 4px;
    background: white;
  }

  .matrix-input:focus {
    outline: none;
    border-color: #2980b9;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
  }

  .group-total {
    margin-top: 10px;
    font-size: 0.9em;
    color: #666;
  }

  .group-total span {
    font-weight: 600;
    color: #2c3e50;
  }

  /* Metric tabs */
  .metric-tabs {
    display: flex;
    gap: 10px;
    margin-top: 20px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  .tab-button {
    flex: 1;
    min-width: 180px;
    padding: 10px 14px;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 0.8em;
    font-weight: 600;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }

  .tab-button:hover {
    border-color: #3498db;
    color: #3498db;
    transform: translateY(-2px);
  }

  .tab-button.active {
    background: #3498db;
    color: white;
    border-color: #3498db;
  }

  @media (max-width: 700px) {
    .metric-tabs {
      flex-direction: column;
    }
    .tab-button {
      width: 100%;
      min-width: 0;
    }
  }

  /* Metric display */
  .metric-title {
    font-size: 1.3em;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0 0 6px 0;
  }

  .metric-question {
    font-size: 1.05em;
    color: #555;
    font-style: italic;
    margin-bottom: 12px;
  }

  .formula-explanation {
    background: #f0f7ff;
    padding: 8px 12px;
    border-radius: 6px;
    margin-bottom: 12px;
    font-size: 0.85em;
    color: #1565c0;
  }

  .formula-explanation strong {
    color: #0d47a1;
  }

  .formula-explanation p {
    margin: 5px 0 0 0;
    color: #495057;
  }

  /* Calculation display */
  .calculation-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    justify-content: center;
  }

  @media (max-width: 600px) {
    .calculation-row {
      flex-direction: column;
    }
  }

  .calc-box {
    flex: 1;
    max-width: 280px;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
  }

  .calc-box h4 {
    margin: 0 0 10px 0;
    font-size: 0.95em;
  }

  .calc-box.group-a-style h4 { color: #2980b9; }
  .calc-box.group-b-style h4 { color: #e67e22; }

  .formula-line {
    font-family: 'Courier New', monospace;
    font-size: 0.85em;
    color: #666;
    margin-bottom: 8px;
  }

  .result-value {
    font-size: 1.3em;
    font-weight: 600;
    color: #2c3e50;
  }

  /* Result box */
  .result-box {
    text-align: center;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
  }

  .result-box.fair {
    background: #e8f5e9;
    border: 1px solid #a5d6a7;
  }

  .result-box.warning {
    background: #fff8e1;
    border: 1px solid #ffe082;
  }

  .result-box.unfair {
    background: #ffebee;
    border: 1px solid #ef9a9a;
  }

  .result-box.unknown {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
  }

  .result-label {
    font-size: 0.85em;
    color: #666;
    margin-bottom: 5px;
  }

  .result-box .result-value {
    font-size: 1.5em;
    font-weight: 600;
  }

  .result-box.fair .result-value { color: #2e7d32; }
  .result-box.warning .result-value { color: #f57f17; }
  .result-box.unfair .result-value { color: #c62828; }
  .result-box.unknown .result-value { color: #666; }

  .result-status {
    font-size: 0.9em;
    margin-top: 5px;
  }

  /* Insight box */
  .insight-box {
    background: #e3f2fd;
    border-left: 4px solid #2196f3;
    padding: 12px 15px;
    border-radius: 0 8px 8px 0;
    font-size: 0.9em;
  }

  /* Results grid for side-by-side layout */
  .results-grid {
    display: grid;
    grid-template-columns: 180px 1fr;
    gap: 15px;
    margin-bottom: 15px;
  }

  @media (max-width: 600px) {
    .results-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Side-by-side container for inputs and results */
  .side-by-side-container {
    display: grid;
    grid-template-columns: 420px 1fr;
    gap: 20px;
    align-items: start;
    margin-top: 15px;
  }

  .inputs-column {
    position: sticky;
    top: 20px;
  }

  .results-column {
    min-width: 0;
  }

  @media (max-width: 1000px) {
    .side-by-side-container {
      grid-template-columns: 1fr;
    }

    .inputs-column {
      position: static;
    }
  }

  /* Footer */
  .key-takeaway {
    background: #fff8e1;
    border-left: 4px solid #ffc107;
    padding: 15px 18px;
    border-radius: 0 8px 8px 0;
    margin-top: 20px;
    font-size: 0.9em;
  }
</style>
</head>
<body>

<div class="container">
  <a href="index.html" class="back-button">‚Üê Back to Home</a>

  <h1>Fairness Metrics Explorer</h1>
  <p class="subtitle">
    Enter confusion matrix values and explore how different metrics measure AI fairness
  </p>

  <!-- Collapsible Introduction -->
  <button class="collapsible-toggle" onclick="toggleIntro()">
    <span>üìö What are confusion matrices and fairness metrics?</span>
    <span class="arrow" id="intro-arrow">‚ñ∂</span>
  </button>
  <div id="intro-content" class="collapsible-content">
    <h3>The Scenario</h3>
    <p>
      Imagine an <strong>AI system that screens patients for disease</strong>. For each patient, it predicts either <strong>POSITIVE</strong> (likely has disease) or <strong>NEGATIVE</strong> (likely healthy). After testing, we compare predictions to reality.
    </p>

    <h3>The Confusion Matrix</h3>
    <p>This 2√ó2 grid shows all possible outcomes:</p>
    <dl>
      <dt>True Positive (TP)</dt>
      <dd>Patient HAS disease, AI correctly said "positive" ‚úì</dd>

      <dt>False Negative (FN)</dt>
      <dd>Patient HAS disease, AI wrongly said "negative" ‚úó (missed diagnosis)</dd>

      <dt>False Positive (FP)</dt>
      <dd>Patient is HEALTHY, AI wrongly said "positive" ‚úó (false alarm)</dd>

      <dt>True Negative (TN)</dt>
      <dd>Patient is HEALTHY, AI correctly said "negative" ‚úì</dd>
    </dl>

    <h3>Why Compare Groups?</h3>
    <p>
      AI systems often perform differently for different populations (e.g., younger vs. older patients, men vs. women).
      Fairness metrics help us detect when these differences are unacceptably large.
    </p>

    <p>
      <strong>In this demo:</strong> Enter confusion matrix values for two groups and see how four different fairness metrics assess whether the AI treats both groups fairly.
    </p>
  </div>

  <!-- How to Fill In Values -->
  <button class="collapsible-toggle" onclick="toggleExample()">
    <span>üí° How do I fill in these values?</span>
    <span class="arrow" id="example-arrow">‚ñ∂</span>
  </button>
  <div id="example-content" class="collapsible-content">
    <h3>Real-World Example: Diabetes Screening Fairness Audit</h3>
    <p>
      You deployed an AI model that screens patients for diabetes. After 6 months,
      you want to check if it's fair across age groups.
    </p>

    <h3>Step 1: Evaluate the Model</h3>
    <p>
      You test it on 200 patients from each group (Group A = Under 50, Group B = Over 50)
      where you know the true outcomes.
    </p>

    <h3>Step 2: Count Results for Group A (Under 50)</h3>
    <ul>
      <li><strong>TP = 89:</strong> 89 patients actually had diabetes ‚Üí model correctly said "positive"</li>
      <li><strong>FN = 15:</strong> 15 patients actually had diabetes ‚Üí model wrongly said "negative" (missed!)</li>
      <li><strong>FP = 10:</strong> 10 patients were healthy ‚Üí model wrongly said "positive" (false alarm)</li>
      <li><strong>TN = 90:</strong> 90 patients were healthy ‚Üí model correctly said "negative"</li>
    </ul>

    <h3>Step 3: Do the Same for Group B (Over 50)</h3>
    <p>TP = 70, FN = 30, FP = 25, TN = 75</p>

    <h3>Step 4: Enter Values & Check Fairness</h3>
    <p>
      Enter these values in the confusion matrices below. The demo calculates whether
      the AI treats both groups fairly using different fairness metrics.
    </p>
  </div>

  <!-- Metric Selection Tabs -->
  <div class="metric-tabs">
    <button class="tab-button active" onclick="showMetric('equal-opportunity')">
      Equal Opportunity
    </button>
    <button class="tab-button" onclick="showMetric('equalized-odds')">
      Equalized Odds
    </button>
    <button class="tab-button" onclick="showMetric('statistical-parity')">
      Statistical Parity
    </button>
    <button class="tab-button" onclick="showMetric('predictive-parity')">
      Predictive Parity
    </button>
  </div>

  <!-- Side-by-Side Container -->
  <div class="side-by-side-container">
    <!-- Inputs Column -->
    <div class="inputs-column">
      <!-- Confusion Matrix Input Card -->
      <div class="card">
    <h2 class="card-title">Confusion Matrix Inputs</h2>
    <p class="card-subtitle">Enter the number of patients in each category for both groups</p>

    <div class="groups-grid">
      <!-- Group A -->
      <div class="group-section">
        <h3 class="group-label group-a">Group A</h3>
        <div class="matrix-input-grid">
          <div class="matrix-corner"></div>
          <div class="matrix-col-header">Predicted<br>Positive</div>
          <div class="matrix-col-header">Predicted<br>Negative</div>

          <div class="matrix-row-header">Actually Has Disease</div>
          <div class="matrix-input-cell tp-cell">
            <label class="cell-label">TP</label>
            <input type="number" id="tp-a" value="85" min="0" class="matrix-input">
          </div>
          <div class="matrix-input-cell fn-cell">
            <label class="cell-label">FN</label>
            <input type="number" id="fn-a" value="15" min="0" class="matrix-input">
          </div>

          <div class="matrix-row-header">Actually Healthy</div>
          <div class="matrix-input-cell fp-cell">
            <label class="cell-label">FP</label>
            <input type="number" id="fp-a" value="10" min="0" class="matrix-input">
          </div>
          <div class="matrix-input-cell tn-cell">
            <label class="cell-label">TN</label>
            <input type="number" id="tn-a" value="90" min="0" class="matrix-input">
          </div>
        </div>
        <div class="group-total">Total: <span id="total-a">200</span></div>
      </div>

      <!-- Group B -->
      <div class="group-section">
        <h3 class="group-label group-b">Group B</h3>
        <div class="matrix-input-grid">
          <div class="matrix-corner"></div>
          <div class="matrix-col-header">Predicted<br>Positive</div>
          <div class="matrix-col-header">Predicted<br>Negative</div>

          <div class="matrix-row-header">Actually Has Disease</div>
          <div class="matrix-input-cell tp-cell">
            <label class="cell-label">TP</label>
            <input type="number" id="tp-b" value="70" min="0" class="matrix-input">
          </div>
          <div class="matrix-input-cell fn-cell">
            <label class="cell-label">FN</label>
            <input type="number" id="fn-b" value="30" min="0" class="matrix-input">
          </div>

          <div class="matrix-row-header">Actually Healthy</div>
          <div class="matrix-input-cell fp-cell">
            <label class="cell-label">FP</label>
            <input type="number" id="fp-b" value="25" min="0" class="matrix-input">
          </div>
          <div class="matrix-input-cell tn-cell">
            <label class="cell-label">TN</label>
            <input type="number" id="tn-b" value="75" min="0" class="matrix-input">
          </div>
        </div>
        <div class="group-total">Total: <span id="total-b">200</span></div>
      </div>
    </div>
  </div>
    </div>
    <!-- End Inputs Column -->

    <!-- Results Column -->
    <div class="results-column">
      <!-- Metric Display Card -->
      <div class="card">
    <div id="metric-content">
      <!-- Content dynamically inserted by JavaScript -->
    </div>
  </div>

      <!-- Key Takeaway -->
      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> These metrics measure different things and can conflict. A model can be "fair" by one metric and "unfair" by another. There's no single definition of fairness‚Äîthe right metric depends on what matters most in your specific healthcare context.
      </div>
    </div>
    <!-- End Results Column -->
  </div>
  <!-- End Side-by-Side Container -->
</div>

<script>
// ===== STATE MANAGEMENT =====
const state = {
  groupA: { tp: 85, fn: 15, fp: 10, tn: 90 },
  groupB: { tp: 70, fn: 30, fp: 25, tn: 75 },
  activeMetric: 'equal-opportunity'
};

// ===== UTILITY FUNCTIONS =====
function safeDivide(numerator, denominator) {
  if (denominator === 0) return null;
  return numerator / denominator;
}

function formatPercent(value) {
  if (value === null) return 'N/A';
  return (value * 100).toFixed(1) + '%';
}

// ===== METRIC CALCULATIONS =====
const metrics = {
  equalOpportunity: (group) => {
    // TPR = TP / (TP + FN)
    return safeDivide(group.tp, group.tp + group.fn);
  },

  equalizedOdds: (group) => {
    // Returns {tpr, fpr}
    const tpr = safeDivide(group.tp, group.tp + group.fn);
    const fpr = safeDivide(group.fp, group.fp + group.tn);
    return { tpr, fpr };
  },

  statisticalParity: (group) => {
    // Selection Rate = (TP + FP) / Total
    const total = group.tp + group.fn + group.fp + group.tn;
    return safeDivide(group.tp + group.fp, total);
  },

  predictiveParity: (group) => {
    // PPV = TP / (TP + FP)
    return safeDivide(group.tp, group.tp + group.fp);
  }
};

// ===== FAIRNESS ASSESSMENT =====
function assessFairness(valueA, valueB, threshold = 0.1) {
  if (valueA === null || valueB === null) {
    return {
      status: 'unknown',
      diff: null,
      message: 'Cannot calculate (check for zero denominators)'
    };
  }

  const diff = Math.abs(valueA - valueB);

  if (diff < threshold) {
    return {
      status: 'fair',
      diff,
      message: 'Fair (<10% difference)'
    };
  } else if (diff < threshold * 2) {
    return {
      status: 'warning',
      diff,
      message: 'Borderline (10-20% difference)'
    };
  } else {
    return {
      status: 'unfair',
      diff,
      message: 'Unfair (>20% difference)'
    };
  }
}

// ===== INPUT HANDLING =====
function handleInputChange() {
  // Read all 8 input values
  state.groupA.tp = parseInt(document.getElementById('tp-a').value) || 0;
  state.groupA.fn = parseInt(document.getElementById('fn-a').value) || 0;
  state.groupA.fp = parseInt(document.getElementById('fp-a').value) || 0;
  state.groupA.tn = parseInt(document.getElementById('tn-a').value) || 0;

  state.groupB.tp = parseInt(document.getElementById('tp-b').value) || 0;
  state.groupB.fn = parseInt(document.getElementById('fn-b').value) || 0;
  state.groupB.fp = parseInt(document.getElementById('fp-b').value) || 0;
  state.groupB.tn = parseInt(document.getElementById('tn-b').value) || 0;

  // Update totals
  updateTotals();

  // Recalculate and re-render active metric
  renderMetricContent(state.activeMetric);
}

function updateTotals() {
  const totalA = state.groupA.tp + state.groupA.fn + state.groupA.fp + state.groupA.tn;
  const totalB = state.groupB.tp + state.groupB.fn + state.groupB.fp + state.groupB.tn;

  document.getElementById('total-a').textContent = totalA;
  document.getElementById('total-b').textContent = totalB;
}

// ===== INSIGHT GENERATION =====
function generateInsight(metricId, valueA, valueB, fairness) {
  if (fairness.status === 'unknown') {
    return "Cannot calculate this metric with current values. Check that denominators are not zero (e.g., ensure TP+FN > 0 for TPR).";
  }

  if (fairness.status === 'fair') {
    switch(metricId) {
      case 'equal-opportunity':
        return "Both groups have similar detection rates. Patients with disease are equally likely to be correctly diagnosed regardless of group.";
      case 'equalized-odds':
        return "Both detection rates (TPR) and false alarm rates (FPR) are similar across groups. The model treats both groups equitably in terms of all error types.";
      case 'statistical-parity':
        return "Both groups are flagged at similar rates. The AI applies the same threshold for positive predictions across groups.";
      case 'predictive-parity':
        return "When the AI predicts positive, it's equally reliable for both groups. A positive result means the same thing regardless of group membership.";
    }
  }

  // Unfair/warning scenarios with dynamic messages
  const diff = formatPercent(fairness.diff);
  const lowerGroup = valueA < valueB ? 'A' : 'B';
  const higherGroup = valueA > valueB ? 'A' : 'B';

  switch(metricId) {
    case 'equal-opportunity':
      return `Group ${lowerGroup} has ${diff} lower detection rate‚Äîmore missed diagnoses.`;
    case 'equalized-odds':
      return `Error rates differ by ${diff} between groups.`;
    case 'statistical-parity':
      return `Group ${higherGroup} flagged ${diff} more often.`;
    case 'predictive-parity':
      return `Positive predictions ${diff} less accurate for Group ${lowerGroup}.`;
  }
}

// ===== METRIC RENDERING =====
function renderEqualOpportunity() {
  const a = state.groupA;
  const b = state.groupB;

  const tprA = metrics.equalOpportunity(a);
  const tprB = metrics.equalOpportunity(b);

  const fairness = assessFairness(tprA, tprB);
  const insight = generateInsight('equal-opportunity', tprA, tprB, fairness);

  return `
    <h2 class="metric-title">Equal Opportunity</h2>
    <p class="metric-question">"Are we catching the disease equally well in both groups?"</p>

    <div class="formula-explanation">
      <strong>TPR = TP / (TP + FN)</strong> ‚Äî % of sick patients correctly identified
    </div>

    <div class="calculation-row">
      <div class="calc-box group-a-style">
        <h4>Group A</h4>
        <div class="formula-line">TPR = ${a.tp} / (${a.tp} + ${a.fn})</div>
        <div class="result-value">${formatPercent(tprA)}</div>
      </div>
      <div class="calc-box group-b-style">
        <h4>Group B</h4>
        <div class="formula-line">TPR = ${b.tp} / (${b.tp} + ${b.fn})</div>
        <div class="result-value">${formatPercent(tprB)}</div>
      </div>
    </div>

    <div class="results-grid">
      <div class="result-box ${fairness.status}">
        <div class="result-label">Difference</div>
        <div class="result-value">${formatPercent(fairness.diff)}</div>
        <div class="result-status">${fairness.message}</div>
      </div>

      <div class="insight-box">
        ${insight}
      </div>
    </div>
  `;
}

function renderEqualizedOdds() {
  const a = state.groupA;
  const b = state.groupB;

  const oddsA = metrics.equalizedOdds(a);
  const oddsB = metrics.equalizedOdds(b);

  let fairness, maxDiff;
  if (oddsA.tpr === null || oddsA.fpr === null || oddsB.tpr === null || oddsB.fpr === null) {
    fairness = {
      status: 'unknown',
      diff: null,
      message: 'Cannot calculate (check for zero denominators)'
    };
    maxDiff = null;
  } else {
    const tprDiff = Math.abs(oddsA.tpr - oddsB.tpr);
    const fprDiff = Math.abs(oddsA.fpr - oddsB.fpr);
    maxDiff = Math.max(tprDiff, fprDiff);
    fairness = assessFairness(0, maxDiff, 0);
    fairness.diff = maxDiff;
  }

  const insight = generateInsight('equalized-odds', oddsA.tpr, oddsB.tpr, fairness);

  return `
    <h2 class="metric-title">Equalized Odds</h2>
    <p class="metric-question">"Are ALL error rates equal?" (both catching disease AND false alarms)</p>

    <div class="formula-explanation">
      <strong>TPR and FPR</strong> ‚Äî Both detection rate and false alarm rate must be equal
    </div>

    <div class="calculation-row">
      <div class="calc-box group-a-style">
        <h4>Group A</h4>
        <div class="formula-line">TPR = ${formatPercent(oddsA.tpr)}</div>
        <div class="formula-line">FPR = ${formatPercent(oddsA.fpr)}</div>
      </div>
      <div class="calc-box group-b-style">
        <h4>Group B</h4>
        <div class="formula-line">TPR = ${formatPercent(oddsB.tpr)}</div>
        <div class="formula-line">FPR = ${formatPercent(oddsB.fpr)}</div>
      </div>
    </div>

    <div class="results-grid">
      <div class="result-box ${fairness.status}">
        <div class="result-label">Max Difference</div>
        <div class="result-value">${formatPercent(fairness.diff)}</div>
        <div class="result-status">${fairness.message}</div>
      </div>

      <div class="insight-box">
        ${insight}
      </div>
    </div>
  `;
}

function renderStatisticalParity() {
  const a = state.groupA;
  const b = state.groupB;

  const rateA = metrics.statisticalParity(a);
  const rateB = metrics.statisticalParity(b);

  const fairness = assessFairness(rateA, rateB);
  const insight = generateInsight('statistical-parity', rateA, rateB, fairness);

  return `
    <h2 class="metric-title">Statistical Parity</h2>
    <p class="metric-question">"Are we flagging patients at equal rates?" (regardless of accuracy)</p>

    <div class="formula-explanation">
      <strong>Rate = (TP + FP) / Total</strong> ‚Äî % flagged as positive
    </div>

    <div class="calculation-row">
      <div class="calc-box group-a-style">
        <h4>Group A</h4>
        <div class="formula-line">Rate = (${a.tp} + ${a.fp}) / ${a.tp + a.fn + a.fp + a.tn}</div>
        <div class="result-value">${formatPercent(rateA)}</div>
      </div>
      <div class="calc-box group-b-style">
        <h4>Group B</h4>
        <div class="formula-line">Rate = (${b.tp} + ${b.fp}) / ${b.tp + b.fn + b.fp + b.tn}</div>
        <div class="result-value">${formatPercent(rateB)}</div>
      </div>
    </div>

    <div class="results-grid">
      <div class="result-box ${fairness.status}">
        <div class="result-label">Difference</div>
        <div class="result-value">${formatPercent(fairness.diff)}</div>
        <div class="result-status">${fairness.message}</div>
      </div>

      <div class="insight-box">
        ${insight}
      </div>
    </div>
  `;
}

function renderPredictiveParity() {
  const a = state.groupA;
  const b = state.groupB;

  const ppvA = metrics.predictiveParity(a);
  const ppvB = metrics.predictiveParity(b);

  const fairness = assessFairness(ppvA, ppvB);
  const insight = generateInsight('predictive-parity', ppvA, ppvB, fairness);

  return `
    <h2 class="metric-title">Predictive Parity</h2>
    <p class="metric-question">"When we predict positive, are we equally accurate for both groups?"</p>

    <div class="formula-explanation">
      <strong>PPV = TP / (TP + FP)</strong> ‚Äî % of positive predictions that are correct
    </div>

    <div class="calculation-row">
      <div class="calc-box group-a-style">
        <h4>Group A</h4>
        <div class="formula-line">PPV = ${a.tp} / (${a.tp} + ${a.fp})</div>
        <div class="result-value">${formatPercent(ppvA)}</div>
      </div>
      <div class="calc-box group-b-style">
        <h4>Group B</h4>
        <div class="formula-line">PPV = ${b.tp} / (${b.tp} + ${b.fp})</div>
        <div class="result-value">${formatPercent(ppvB)}</div>
      </div>
    </div>

    <div class="results-grid">
      <div class="result-box ${fairness.status}">
        <div class="result-label">Difference</div>
        <div class="result-value">${formatPercent(fairness.diff)}</div>
        <div class="result-status">${fairness.message}</div>
      </div>

      <div class="insight-box">
        ${insight}
      </div>
    </div>
  `;
}

function renderMetricContent(metricId) {
  state.activeMetric = metricId;

  const container = document.getElementById('metric-content');

  switch(metricId) {
    case 'equal-opportunity':
      container.innerHTML = renderEqualOpportunity();
      break;
    case 'equalized-odds':
      container.innerHTML = renderEqualizedOdds();
      break;
    case 'statistical-parity':
      container.innerHTML = renderStatisticalParity();
      break;
    case 'predictive-parity':
      container.innerHTML = renderPredictiveParity();
      break;
  }
}

// ===== TAB NAVIGATION =====
function showMetric(metricId) {
  // Update tab active states
  document.querySelectorAll('.tab-button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');

  // Render new metric content
  renderMetricContent(metricId);
}

// ===== COLLAPSIBLE INTRO =====
function toggleIntro() {
  const content = document.getElementById('intro-content');
  const arrow = document.getElementById('intro-arrow');

  content.classList.toggle('visible');
  arrow.classList.toggle('open');
}

// ===== COLLAPSIBLE EXAMPLE =====
function toggleExample() {
  const content = document.getElementById('example-content');
  const arrow = document.getElementById('example-arrow');

  content.classList.toggle('visible');
  arrow.classList.toggle('open');
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', () => {
  // Add input change listeners
  const inputs = ['tp-a', 'fn-a', 'fp-a', 'tn-a', 'tp-b', 'fn-b', 'fp-b', 'tn-b'];
  inputs.forEach(id => {
    document.getElementById(id).addEventListener('input', handleInputChange);
  });

  // Initial render
  updateTotals();
  renderMetricContent('equal-opportunity');
});
</script>

</body>
</html>
