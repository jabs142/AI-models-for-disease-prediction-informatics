<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Temporal Drift - Diabetes Risk Prediction Model</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #f7f8fa;
    color: #2c3e50;
    margin: 0;
    padding: 20px;
    line-height: 1.6;
  }
  .container {
    max-width: 1000px;
    margin: 0 auto;
  }
  h1 {
    font-size: 1.4em;
    margin-bottom: 0.3em;
    color: #1a1a1a;
  }
  .subtitle {
    color: #666;
    font-size: 0.9em;
    margin-bottom: 20px;
  }
  .back-button {
    display: inline-block;
    margin-bottom: 15px;
    padding: 8px 16px;
    background: #3498db;
    color: white;
    text-decoration: none;
    border-radius: 6px;
    font-size: 0.85em;
    font-weight: 500;
  }
  .back-button:hover {
    background: #2980b9;
  }

  /* Scenario card */
  .scenario-card {
    background: white;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: 4px solid #3498db;
  }
  .scenario-card h2 {
    font-size: 1em;
    margin: 0 0 10px 0;
    color: #1a1a1a;
  }
  .scenario-card p {
    font-size: 0.9em;
    margin: 5px 0;
    color: #495057;
  }

  /* Slider section */
  .slider-section {
    background: white;
    border-radius: 10px;
    padding: 15px 20px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  .slider-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.85em;
    color: #666;
    margin-bottom: 8px;
  }
  .slider-labels .current {
    font-weight: 600;
    color: #3498db;
  }
  input[type="range"] {
    width: 100%;
    margin: 0;
    height: 6px;
    border-radius: 3px;
    background: #ddd;
    outline: none;
    -webkit-appearance: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3498db;
    cursor: pointer;
  }
  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3498db;
    cursor: pointer;
    border: none;
  }
  .slider-hint {
    font-size: 0.75em;
    color: #999;
    text-align: center;
    margin-top: 4px;
  }

  /* Reset button */
  .reset-button {
    display: block;
    margin: 0 auto 15px auto;
    padding: 8px 16px;
    background: #6c757d;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 0.85em;
    cursor: pointer;
    transition: background 0.2s;
    font-family: inherit;
  }
  .reset-button:hover {
    background: #5a6268;
  }

  /* Main grid */
  .main-grid {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 15px;
    margin-bottom: 15px;
  }

  @media (max-width: 800px) {
    .main-grid {
      grid-template-columns: 1fr;
    }
  }

  .panel {
    background: white;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  .panel-title {
    font-weight: 600;
    font-size: 0.95em;
    margin-bottom: 12px;
    color: #2c3e50;
  }

  /* HbA1c chart */
  #hba1cChart {
    width: 100%;
    height: 160px;
  }
  .hba1c-stats {
    display: flex;
    justify-content: space-between;
    font-size: 0.85em;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #eee;
  }
  .hba1c-stat {
    text-align: center;
  }
  .hba1c-stat-value {
    font-weight: 600;
    font-size: 1.1em;
  }
  .hba1c-stat-label {
    color: #666;
    font-size: 0.9em;
  }

  /* Accuracy panel */
  .accuracy-panel {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
  }
  .metric-label {
    font-size: 0.75em;
    color: #666;
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .accuracy-value {
    font-size: 2.8em;
    font-weight: bold;
    color: #2c3e50;
    line-height: 1;
  }
  .metric-description {
    font-size: 0.85em;
    color: #666;
    margin-top: -4px;
    margin-bottom: 8px;
  }
  .accuracy-change {
    font-size: 1.1em;
    margin: 8px 0;
  }
  .accuracy-change.good { color: #28a745; }
  .accuracy-change.warning { color: #f57c00; }
  .accuracy-change.critical { color: #dc3545; }
  .badge {
    font-size: 0.75em;
    padding: 5px 12px;
    border-radius: 12px;
    font-weight: 500;
    margin: 8px 0;
  }
  .badge.deployed { background: #e3f2fd; color: #1976d2; }
  .badge.warning { background: #fff3e0; color: #f57c00; }
  .badge.critical { background: #ffebee; color: #c62828; }
  .status-text {
    font-size: 0.85em;
    color: #666;
    margin-top: 5px;
  }
  .info-button {
    font-size: 0.8em;
    padding: 4px 10px;
    background: #e3f2fd;
    color: #1976d2;
    border: 1px solid #90caf9;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 8px;
    font-family: inherit;
  }
  .info-button:hover {
    background: #bbdefb;
  }
  .metric-info {
    display: none;
    margin-top: 12px;
    padding: 12px;
    background: #f8f9fa;
    border-radius: 6px;
    font-size: 0.8em;
    line-height: 1.5;
    color: #495057;
    text-align: left;
  }
  .metric-info.visible {
    display: block;
  }
  .metric-info strong {
    color: #2c3e50;
  }

  /* Drift indicator */
  .drift-indicator {
    font-size: 0.85em;
    margin: 8px 0;
    padding: 8px 10px;
    background: #f0f4ff;
    border-radius: 6px;
    border-left: 3px solid #3498db;
    width: 100%;
  }
  .drift-label {
    color: #1976d2;
    font-weight: 600;
  }
  .drift-value {
    color: #1976d2;
    font-weight: 700;
    font-size: 1.1em;
  }

  /* Collapsible section */
  .collapsible-toggle {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 12px 16px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    font-size: 0.9em;
    font-weight: 600;
    color: #495057;
    cursor: pointer;
    font-family: inherit;
  }
  .collapsible-toggle:hover {
    border-color: #3498db;
    color: #3498db;
  }
  .collapsible-arrow {
    transition: transform 0.2s;
    color: #3498db;
  }
  .collapsible-arrow.open {
    transform: rotate(90deg);
  }
  .collapsible-content {
    display: none;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 20px;
    margin-top: 10px;
  }
  .collapsible-content.visible {
    display: block;
  }
  .collapsible-content h4 {
    color: #2c3e50;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 1em;
  }
  .collapsible-content h4:first-child {
    margin-top: 0;
  }
  .collapsible-content p {
    margin-bottom: 1em;
    color: #495057;
    font-size: 0.9em;
  }
  .collapsible-content ul {
    padding-left: 20px;
    margin-bottom: 1em;
    font-size: 0.9em;
  }
  .collapsible-content li {
    margin-bottom: 6px;
  }
  .key-takeaway {
    background: #e8f5e9;
    padding: 15px 18px;
    border-left: 4px solid #28a745;
    border-radius: 6px;
    margin-top: 20px;
    font-size: 0.9em;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>

<div class="container">
  <a href="index.html" class="back-button">← Back to Home</a>

  <h1>Why Models Fail: Temporal Drift</h1>
  <div class="subtitle">
    Watch how changing patient populations degrade model accuracy over time
  </div>

  <!-- Scenario card -->
  <div class="scenario-card">
    <h2>Diabetes Clinic</h2>
    <p>
      Your AI model was trained in 2022 on patients with stable Type 2 diabetes (HbA1c 6.0-9.0%) to predict 1-year hospitalization risk. The model achieved 88% accuracy.
    </p>
    <p>
      In 2023, a nearby community health center closed, and its patients—many with poorly controlled diabetes—were transferred to your clinic. The patient population's average HbA1c increased from 7.2% to 9.1%, and your model's accuracy dropped to 76%.
    </p>
  </div>

  <!-- Slider controls -->
  <div class="slider-section">
    <div class="slider-labels">
      <span>Well Controlled</span>
      <span class="current" id="currentMean">Population Avg: 7.2%</span>
      <span>Poorly Controlled</span>
    </div>
    <input type="range" id="meanControl" min="6.5" max="10.5" step="0.1" value="7.2">
    <div class="slider-hint">Training average: 7.2%</div>
  </div>

  <div class="slider-section">
    <div class="slider-labels">
      <span>Homogeneous</span>
      <span class="current" id="currentSpread">Spread: Moderate</span>
      <span>Heterogeneous</span>
    </div>
    <input type="range" id="spreadControl" min="0.8" max="2.2" step="0.1" value="1.2">
    <div class="slider-hint">Training spread: 1.2 (std dev)</div>
  </div>

  <button class="reset-button" onclick="resetDistribution()">↻ Reset to Training Distribution</button>

  <!-- Main content: HbA1c distribution + Accuracy -->
  <div class="main-grid">
    <div class="panel">
      <div class="panel-title">Patient HbA1c Distribution</div>
      <div style="font-size: 0.8em; color: #666; margin-bottom: 8px; line-height: 1.4;">
        Shows how many patients have each blood sugar control level. <strong style="color: #3498db;">Blue</strong> = training data, <strong style="color: #e74c3c;">Red</strong> = current population.
      </div>
      <canvas id="hba1cChart"></canvas>
      <div class="hba1c-stats">
        <div class="hba1c-stat">
          <div class="hba1c-stat-value" style="color: #3498db;">7.2%</div>
          <div class="hba1c-stat-label">Training avg HbA1c</div>
        </div>
        <div class="hba1c-stat">
          <div class="hba1c-stat-value" id="currentAvgHbA1c" style="color: #e74c3c;">7.2%</div>
          <div class="hba1c-stat-label">Current avg HbA1c</div>
        </div>
      </div>
    </div>

    <div class="panel accuracy-panel">
      <div class="metric-label">Model Performance</div>
      <div class="accuracy-value" id="accuracyValue">88.0%</div>
      <div class="metric-description">Overall Accuracy</div>
      <div class="accuracy-change good" id="accuracyChange">Baseline</div>

      <div class="drift-indicator">
        <span class="drift-label">Patients outside training range: </span>
        <span class="drift-value" id="outsidePercent">0%</span>
      </div>

      <span class="badge deployed" id="statusBadge">Deployed</span>
      <div class="status-text" id="statusText">Model performing well</div>

      <button class="info-button" onclick="toggleMetricInfo()">ⓘ What does this mean?</button>
      <div class="metric-info" id="metricInfo">
        <strong>Overall Accuracy:</strong> Percentage of predictions that are correct (both high-risk and low-risk).<br><br>
        <strong>Missed Hospitalizations (<span id="missedHosp" style="color: #856404; font-weight: 700;">3.2%</span>):</strong> Percentage of patients who were hospitalized within 1 year but whom the model predicted as low-risk. This is the most dangerous type of error—patients who needed intervention but didn't receive it.<br><br>
        <strong>Why These Metrics?</strong> Accuracy shows overall performance, while missed hospitalizations shows clinical safety. Both degrade when patient HbA1c distribution drifts away from training data.
      </div>
    </div>
  </div>

  <!-- Collapsible deep dive -->
  <button class="collapsible-toggle" onclick="toggleDeepDive()">
    <span>Technical Deep Dive: Understanding Temporal Drift</span>
    <span class="collapsible-arrow" id="deepDiveArrow">›</span>
  </button>

  <div class="collapsible-content" id="deepDiveContent">
    <h4>What Is Temporal Drift?</h4>
    <p>
      <strong>Temporal drift</strong> occurs when production data differs from training data. Unlike sudden failures, drift is gradual—accuracy erodes over weeks or months as patient populations change.
    </p>

    <h4>Sources of Drift in This Demo</h4>
    <ul>
      <li><strong>Referral pattern change:</strong> Community health center closure sent poorly controlled diabetic patients to this clinic</li>
      <li><strong>Distribution shift:</strong> The population's HbA1c distribution moved beyond the range the model was trained on (6.0-9.0%), causing predictions to become unreliable</li>
      <li><strong>Distribution tail shift:</strong> Model now sees extreme HbA1c values (>10%) that were rare in training data</li>
    </ul>

    <h4>How to Detect Drift</h4>
    <ul>
      <li><strong>Performance monitoring:</strong> Track accuracy on held-out test sets over time</li>
      <li><strong>Distribution monitoring:</strong> Use statistical tests to detect when input distributions shift</li>
      <li><strong>Feature monitoring:</strong> Watch for changes in key feature distributions</li>
    </ul>

    <h4>Mitigation Strategies</h4>
    <ul>
      <li><strong>Scheduled retraining:</strong> Retrain quarterly with recent patient outcomes</li>
      <li><strong>Subpopulation monitoring:</strong> Track performance separately for HbA1c <8% vs >8% cohorts</li>
      <li><strong>Drift-aware models:</strong> Use domain adaptation or online learning techniques</li>
      <li><strong>Alerts:</strong> Trigger automatic alerts when input distributions deviate >20% from training</li>
    </ul>

    <div class="key-takeaway">
      <strong>Key Takeaway:</strong> Healthcare populations change. A model trained on stable diabetes patients may fail catastrophically when deployed to a clinic serving sicker patients. Continuous monitoring of both model performance AND input distributions is essential for patient safety.
    </div>
  </div>
</div>

<script>
// Canvas setup
const hba1cCanvas = document.getElementById('hba1cChart');
const hba1cCtx = hba1cCanvas.getContext('2d');

// Setup canvases for high-DPI
function setupCanvas(canvas) {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  const ctx = canvas.getContext('2d');
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  return { width: rect.width, height: rect.height };
}

const hba1cDims = setupCanvas(hba1cCanvas);

// Training parameters
const trainingHbA1c = {
  mean: 7.2,
  std: 1.2,
  min: 4.0,
  max: 12.0
};
const trainingRange = { min: 6.0, max: 9.0 };

// Get current distribution
function getCurrentDistribution() {
  return {
    mean: parseFloat(document.getElementById('meanControl').value),
    std: parseFloat(document.getElementById('spreadControl').value)
  };
}

// Performance calculation
const baselineAccuracy = 88.0;
const baselineMissedHosp = 3.2;

function getPerformance(meanHbA1c, stdHbA1c) {
  const meanDrift = Math.abs(meanHbA1c - 7.2);
  const stdDrift = Math.abs(stdHbA1c - 1.2);

  const accuracy = Math.max(65,
    baselineAccuracy - (meanDrift * 2.8) - (stdDrift * 3.5)
  );

  const missedHosp = Math.min(22,
    baselineMissedHosp + (meanDrift * 1.2) + (stdDrift * 1.8)
  );

  return { accuracy, missedHosp };
}

// Calculate percentage outside training range
function getOutsidePercentage(mean, std) {
  function normalCDF(x, mean, std) {
    const z = (x - mean) / std;
    const t = 1 / (1 + 0.2316419 * Math.abs(z));
    const d = 0.3989423 * Math.exp(-z * z / 2);
    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return z > 0 ? 1 - p : p;
  }
  const withinRange = normalCDF(trainingRange.max, mean, std) - normalCDF(trainingRange.min, mean, std);
  return Math.round((1 - withinRange) * 100);
}

// Draw HbA1c distribution chart
function drawHbA1cChart(dist) {
  const w = hba1cDims.width;
  const h = hba1cDims.height;
  hba1cCtx.clearRect(0, 0, w, h);

  const padding = { top: 10, right: 15, bottom: 25, left: 15 };
  const plotWidth = w - padding.left - padding.right;
  const plotHeight = h - padding.top - padding.bottom;

  const min = 4.0, max = 12.0;

  // Generate curves
  function getCurvePoints(mean, std) {
    const points = [];
    let maxVal = 0;
    for (let x = min; x <= max; x += 0.1) {
      const z = (x - mean) / std;
      const y = Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
      maxVal = Math.max(maxVal, y);
      points.push({ x, y });
    }
    return { points, maxVal };
  }

  const training = getCurvePoints(trainingHbA1c.mean, trainingHbA1c.std);
  const current = getCurvePoints(dist.mean, dist.std);
  const globalMax = Math.max(training.maxVal, current.maxVal);

  // Draw training range shading
  const rangeStartX = padding.left + ((trainingRange.min - min) / (max - min)) * plotWidth;
  const rangeEndX = padding.left + ((trainingRange.max - min) / (max - min)) * plotWidth;
  hba1cCtx.fillStyle = 'rgba(40, 167, 69, 0.1)';
  hba1cCtx.fillRect(rangeStartX, padding.top, rangeEndX - rangeStartX, plotHeight);

  // Draw x-axis
  hba1cCtx.strokeStyle = '#dee2e6';
  hba1cCtx.lineWidth = 1;
  hba1cCtx.beginPath();
  hba1cCtx.moveTo(padding.left, h - padding.bottom);
  hba1cCtx.lineTo(w - padding.right, h - padding.bottom);
  hba1cCtx.stroke();

  // X-axis labels
  hba1cCtx.fillStyle = '#6c757d';
  hba1cCtx.font = '10px sans-serif';
  hba1cCtx.textAlign = 'center';
  for (let val = 4; val <= 12; val += 2) {
    const x = padding.left + ((val - min) / (max - min)) * plotWidth;
    hba1cCtx.fillText(val + '%', x, h - padding.bottom + 14);
  }

  // X-axis label with arrows
  hba1cCtx.fillStyle = '#495057';
  hba1cCtx.font = '9px sans-serif';
  hba1cCtx.textAlign = 'left';
  hba1cCtx.fillText('← Well Controlled', padding.left, h - 2);
  hba1cCtx.textAlign = 'right';
  hba1cCtx.fillText('Poorly Controlled →', w - padding.right, h - 2);

  // Training range label
  hba1cCtx.fillStyle = '#28a745';
  hba1cCtx.font = '9px sans-serif';
  hba1cCtx.fillText('Training Range', (rangeStartX + rangeEndX) / 2, padding.top + 12);

  // Helper to draw a curve
  function drawCurve(points, color, fillColor) {
    // Fill
    hba1cCtx.beginPath();
    hba1cCtx.moveTo(padding.left, h - padding.bottom);
    points.forEach(p => {
      const px = padding.left + ((p.x - min) / (max - min)) * plotWidth;
      const py = h - padding.bottom - (p.y / globalMax) * plotHeight;
      hba1cCtx.lineTo(px, py);
    });
    hba1cCtx.lineTo(w - padding.right, h - padding.bottom);
    hba1cCtx.closePath();
    hba1cCtx.fillStyle = fillColor;
    hba1cCtx.fill();

    // Line
    hba1cCtx.beginPath();
    points.forEach((p, i) => {
      const px = padding.left + ((p.x - min) / (max - min)) * plotWidth;
      const py = h - padding.bottom - (p.y / globalMax) * plotHeight;
      if (i === 0) hba1cCtx.moveTo(px, py);
      else hba1cCtx.lineTo(px, py);
    });
    hba1cCtx.strokeStyle = color;
    hba1cCtx.lineWidth = 2.5;
    hba1cCtx.stroke();
  }

  // Draw training distribution (blue)
  drawCurve(training.points, '#3498db', 'rgba(52, 152, 219, 0.2)');

  // Draw current distribution (red) - only if different
  const isDifferent = Math.abs(dist.mean - trainingHbA1c.mean) > 0.05 ||
                      Math.abs(dist.std - trainingHbA1c.std) > 0.05;
  if (isDifferent) {
    drawCurve(current.points, '#e74c3c', 'rgba(231, 76, 60, 0.2)');
  }

  // Legend
  hba1cCtx.font = '10px sans-serif';
  hba1cCtx.fillStyle = '#3498db';
  hba1cCtx.fillRect(w - 100, 8, 12, 3);
  hba1cCtx.fillStyle = '#495057';
  hba1cCtx.textAlign = 'left';
  hba1cCtx.fillText('Training', w - 85, 12);

  if (isDifferent) {
    hba1cCtx.fillStyle = '#e74c3c';
    hba1cCtx.fillRect(w - 100, 20, 12, 3);
    hba1cCtx.fillStyle = '#495057';
    hba1cCtx.fillText('Current', w - 85, 24);
  }
}

// Update all displays
function updateDashboard() {
  const dist = getCurrentDistribution();
  const { accuracy, missedHosp } = getPerformance(dist.mean, dist.std);

  // Update mean label
  document.getElementById('currentMean').textContent =
    `Population Avg: ${dist.mean.toFixed(1)}%`;

  // Update spread label
  let spreadLabel;
  if (dist.std < 1.1) spreadLabel = "Narrow (Homogeneous)";
  else if (dist.std < 1.7) spreadLabel = "Moderate";
  else spreadLabel = "Wide (Heterogeneous)";
  document.getElementById('currentSpread').textContent =
    `Spread: ${spreadLabel}`;

  // Update accuracy
  document.getElementById('accuracyValue').textContent =
    accuracy.toFixed(1) + '%';

  // Update missed hospitalizations
  document.getElementById('missedHosp').textContent =
    missedHosp.toFixed(1) + '%';

  // Update status badge and change indicator
  const drop = baselineAccuracy - accuracy;
  const changeEl = document.getElementById('accuracyChange');
  const badgeEl = document.getElementById('statusBadge');
  const statusEl = document.getElementById('statusText');

  if (drop < 1) {
    changeEl.textContent = 'Baseline';
    changeEl.className = 'accuracy-change good';
    badgeEl.textContent = 'Deployed';
    badgeEl.className = 'badge deployed';
    statusEl.textContent = 'Model performing well';
  } else if (drop < 5) {
    changeEl.textContent = '↓ ' + drop.toFixed(1) + '%';
    changeEl.className = 'accuracy-change warning';
    badgeEl.textContent = 'Monitoring';
    badgeEl.className = 'badge warning';
    statusEl.textContent = 'Performance drift detected';
  } else {
    changeEl.textContent = '↓ ' + drop.toFixed(1) + '%';
    changeEl.className = 'accuracy-change critical';
    badgeEl.textContent = 'Action Required';
    badgeEl.className = 'badge critical';
    statusEl.textContent = 'Retraining recommended';
  }

  // Update HbA1c stats
  document.getElementById('currentAvgHbA1c').textContent = dist.mean.toFixed(1) + '%';
  document.getElementById('outsidePercent').textContent = getOutsidePercentage(dist.mean, dist.std) + '%';

  // Draw chart
  drawHbA1cChart(dist);
}

// Reset distribution
function resetDistribution() {
  document.getElementById('meanControl').value = 7.2;
  document.getElementById('spreadControl').value = 1.2;
  updateDashboard();
}

// Toggle metric info
function toggleMetricInfo() {
  const infoEl = document.getElementById('metricInfo');
  infoEl.classList.toggle('visible');
}

// Collapsible toggle
function toggleDeepDive() {
  const content = document.getElementById('deepDiveContent');
  const arrow = document.getElementById('deepDiveArrow');
  content.classList.toggle('visible');
  arrow.classList.toggle('open');
}

// Initialize
document.getElementById('meanControl').addEventListener('input', updateDashboard);
document.getElementById('spreadControl').addEventListener('input', updateDashboard);
updateDashboard();
</script>

</body>
</html>
